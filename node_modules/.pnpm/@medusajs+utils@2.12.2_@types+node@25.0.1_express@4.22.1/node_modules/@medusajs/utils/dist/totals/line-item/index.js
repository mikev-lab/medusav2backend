"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLineItemsTotals = getLineItemsTotals;
exports.getLineItemTotals = getLineItemTotals;
const common_1 = require("../../common");
const adjustment_1 = require("../adjustment");
const big_number_1 = require("../big-number");
const math_1 = require("../math");
const tax_1 = require("../tax");
function getLineItemsTotals(items, context) {
    const itemsTotals = {};
    let index = 0;
    for (const item of items) {
        itemsTotals[item.id ?? index] = getLineItemTotals(item, {
            includeTax: context.includeTax || item.is_tax_inclusive,
            extraQuantityFields: context.extraQuantityFields,
        });
        index++;
    }
    return itemsTotals;
}
function setRefundableTotal(item, discountsTotal, totals) {
    const itemDetail = item.detail;
    const totalReturnedQuantity = math_1.MathBN.sum(itemDetail.return_requested_quantity ?? 0, itemDetail.return_received_quantity ?? 0, itemDetail.return_dismissed_quantity ?? 0);
    const currentQuantity = math_1.MathBN.sub(item.quantity, totalReturnedQuantity);
    const discountPerUnit = math_1.MathBN.div(discountsTotal, item.quantity);
    const refundableSubTotal = math_1.MathBN.sub(math_1.MathBN.mult(currentQuantity, item.unit_price), math_1.MathBN.mult(currentQuantity, discountPerUnit));
    const taxTotal = (0, tax_1.calculateTaxTotal)({
        isTaxInclusive: item.is_tax_inclusive,
        taxLines: item.tax_lines || [],
        taxableAmount: refundableSubTotal,
    });
    const refundableTotal = math_1.MathBN.add(refundableSubTotal, taxTotal);
    totals.refundable_total_per_unit = new big_number_1.BigNumber(math_1.MathBN.eq(currentQuantity, 0)
        ? 0
        : math_1.MathBN.div(refundableTotal, currentQuantity));
    totals.refundable_total = new big_number_1.BigNumber(refundableTotal);
}
function getLineItemTotals(item, context) {
    const isTaxInclusive = item.is_tax_inclusive ?? context.includeTax;
    const sumTax = math_1.MathBN.sum(...((item.tax_lines ?? []).map((taxLine) => taxLine.rate) ?? []));
    const sumTaxRate = math_1.MathBN.div(sumTax, 100);
    const totalItemPrice = math_1.MathBN.mult(item.unit_price, item.quantity);
    /*
      If the price is inclusive of tax, we need to remove the taxed amount from the subtotal
      Original Price = Total Price / (1 + Tax Rate)
    */
    const subtotal = isTaxInclusive
        ? math_1.MathBN.div(totalItemPrice, math_1.MathBN.add(1, sumTaxRate))
        : totalItemPrice;
    // Proportional discounts to current quantity and compute taxes on the current net amount
    const { adjustmentsTotal: discountsTotal, adjustmentsSubtotal: discountsSubtotalFull, adjustmentSubtotalPerItem, } = (0, adjustment_1.calculateAdjustmentTotal)({
        item,
        adjustments: item.adjustments || [],
        taxRate: sumTaxRate,
    });
    const itemDetail = item.detail;
    const totalReturnedQuantity = math_1.MathBN.sum(itemDetail?.return_received_quantity ?? 0, itemDetail?.return_dismissed_quantity ?? 0);
    const currentQuantity = math_1.MathBN.sub(item.quantity, totalReturnedQuantity);
    const currentTotalItemPrice = math_1.MathBN.mult(item.unit_price, currentQuantity);
    const currentSubtotal = isTaxInclusive
        ? math_1.MathBN.div(currentTotalItemPrice, math_1.MathBN.add(1, sumTaxRate))
        : currentTotalItemPrice;
    const currentDiscountsSubtotal = math_1.MathBN.mult(adjustmentSubtotalPerItem ?? 0, currentQuantity);
    const taxTotal = (0, tax_1.calculateTaxTotal)({
        taxLines: item.tax_lines || [],
        taxableAmount: math_1.MathBN.sub(currentSubtotal, currentDiscountsSubtotal),
        setTotalField: "total",
    });
    const originalTaxTotal = (0, tax_1.calculateTaxTotal)({
        taxLines: item.tax_lines || [],
        taxableAmount: currentSubtotal,
        setTotalField: "subtotal",
    });
    // Compute full-quantity net total after discounts and taxes to derive per-unit totals
    const fullDiscountedTaxable = math_1.MathBN.sub(subtotal, discountsSubtotalFull ?? 0);
    const taxTotalFull = (0, tax_1.calculateTaxTotal)({
        taxLines: item.tax_lines || [],
        taxableAmount: fullDiscountedTaxable,
    });
    const fullNetTotal = math_1.MathBN.sum(fullDiscountedTaxable, taxTotalFull);
    const totals = {
        quantity: item.quantity,
        unit_price: item.unit_price,
        subtotal: new big_number_1.BigNumber(currentSubtotal),
        total: new big_number_1.BigNumber(math_1.MathBN.sum(math_1.MathBN.sub(currentSubtotal, currentDiscountsSubtotal), taxTotal)),
        original_subtotal: new big_number_1.BigNumber(math_1.MathBN.sub(isTaxInclusive
            ? currentTotalItemPrice
            : math_1.MathBN.add(currentSubtotal, originalTaxTotal), originalTaxTotal)),
        original_total: new big_number_1.BigNumber(isTaxInclusive
            ? currentTotalItemPrice
            : math_1.MathBN.add(currentSubtotal, originalTaxTotal)),
        // Discount values prorated to the current quantity
        discount_subtotal: new big_number_1.BigNumber(currentDiscountsSubtotal),
        discount_tax_total: new big_number_1.BigNumber(math_1.MathBN.sub(originalTaxTotal, taxTotal)),
        discount_total: new big_number_1.BigNumber(math_1.MathBN.add(currentDiscountsSubtotal, math_1.MathBN.sub(originalTaxTotal, taxTotal))),
        tax_total: new big_number_1.BigNumber(taxTotal),
        original_tax_total: new big_number_1.BigNumber(originalTaxTotal),
    };
    if ((0, common_1.isDefined)(item.detail?.return_requested_quantity) ||
        (0, common_1.isDefined)(item.detail?.return_received_quantity) ||
        (0, common_1.isDefined)(item.detail?.return_dismissed_quantity)) {
        setRefundableTotal(item, discountsTotal, totals);
    }
    // Per-unit total should be based on full-quantity net total to support lifecycle totals consistently
    const div = math_1.MathBN.eq(item.quantity, 0) ? 1 : item.quantity;
    const totalPerUnit = math_1.MathBN.div(fullNetTotal, div);
    const optionalFields = {
        ...(context.extraQuantityFields ?? {}),
    };
    for (const field in optionalFields) {
        const totalField = optionalFields[field];
        let target = field.includes(".")
            ? (0, common_1.pickValueFromObject)(field, item)
            : item[field];
        if (!(0, common_1.isDefined)(target)) {
            continue;
        }
        totals[totalField] = new big_number_1.BigNumber(math_1.MathBN.mult(totalPerUnit, target));
    }
    return totals;
}
//# sourceMappingURL=index.js.map