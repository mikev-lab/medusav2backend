"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyTranslations = applyTranslations;
const container_1 = require("../common/container");
const is_object_1 = require("../common/is-object");
const flag_router_1 = require("../feature-flags/flag-router");
const excludedKeys = [
    "id",
    "created_at",
    "updated_at",
    "deleted_at",
    "metadata",
];
function canApplyTranslationTo(object) {
    return "id" in object && !!object.id;
}
function gatherIds(object, gatheredIds) {
    gatheredIds.add(object.id);
    Object.entries(object).forEach(([, value]) => {
        if (Array.isArray(value)) {
            value.forEach((item) => item && gatherIds(item, gatheredIds));
        }
        else if ((0, is_object_1.isObject)(value)) {
            gatherIds(value, gatheredIds);
        }
    });
}
function applyTranslation(object, entityIdToTranslation) {
    const translation = entityIdToTranslation.get(object.id);
    const hasTranslation = !!translation;
    Object.entries(object).forEach(([key, value]) => {
        if (excludedKeys.includes(key)) {
            return;
        }
        if (hasTranslation) {
            if (key in translation &&
                typeof object[key] === typeof translation[key]) {
                object[key] = translation[key];
                return;
            }
        }
        if (Array.isArray(value)) {
            value.forEach((item) => item &&
                canApplyTranslationTo(item) &&
                applyTranslation(item, entityIdToTranslation));
        }
        else if ((0, is_object_1.isObject)(value) && canApplyTranslationTo(value)) {
            applyTranslation(value, entityIdToTranslation);
        }
    });
}
async function applyTranslations({ localeCode, objects, container, }) {
    const isTranslationEnabled = flag_router_1.FeatureFlag.isFeatureEnabled("translation");
    if (!isTranslationEnabled) {
        return;
    }
    const locale = localeCode;
    if (!locale) {
        return;
    }
    const objects_ = objects.filter((o) => !!o);
    if (!objects_.length) {
        return;
    }
    const gatheredIds = new Set();
    for (const inputObject of objects_) {
        gatherIds(inputObject, gatheredIds);
    }
    const query = container.resolve(container_1.ContainerRegistrationKeys.QUERY);
    const queryBatchSize = 250;
    const queryBatches = Math.ceil(gatheredIds.size / queryBatchSize);
    const entityIdToTranslation = new Map();
    for (let i = 0; i < queryBatches; i++) {
        // TODO: concurrently fetch if needed
        const queryBatch = Array.from(gatheredIds)
            .slice(i * queryBatchSize, (i + 1) * queryBatchSize)
            .sort();
        const { data: translations } = await query.graph({
            entity: "translations",
            fields: ["translations", "reference_id"],
            filters: {
                reference_id: queryBatch,
                locale_code: locale,
            },
            pagination: {
                take: queryBatchSize,
            },
        }, {
            cache: { enable: true },
        });
        for (const translation of translations) {
            entityIdToTranslation.set(translation.reference_id, translation.translations ?? {});
        }
    }
    for (const inputObject of objects_) {
        applyTranslation(inputObject, entityIdToTranslation);
    }
}
//# sourceMappingURL=apply-translations.js.map