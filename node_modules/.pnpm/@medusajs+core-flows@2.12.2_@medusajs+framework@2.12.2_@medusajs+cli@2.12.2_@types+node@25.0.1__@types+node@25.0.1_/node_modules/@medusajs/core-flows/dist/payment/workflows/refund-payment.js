"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.refundPaymentWorkflow = exports.refundPaymentWorkflowId = exports.validateRefundPaymentExceedsCapturedAmountStep = void 0;
const utils_1 = require("@medusajs/framework/utils");
const workflows_sdk_1 = require("@medusajs/framework/workflows-sdk");
const common_1 = require("../../common");
const add_order_transaction_1 = require("../../order/steps/add-order-transaction");
const create_order_refund_credit_lines_1 = require("../../order/workflows/payments/create-order-refund-credit-lines");
const refund_payment_1 = require("../steps/refund-payment");
/**
 * This step validates that an order refund credit line can be issued
 */
exports.validateRefundPaymentExceedsCapturedAmountStep = (0, workflows_sdk_1.createStep)("validate-refund-payment-exceeds-captured-amount", async function ({ payment, refundAmount, }) {
    const capturedAmount = (payment.captures || []).reduce((captureAmount, next) => {
        const amountAsBigNumber = new utils_1.BigNumber(next.raw_amount);
        return utils_1.MathBN.add(captureAmount, amountAsBigNumber);
    }, utils_1.MathBN.convert(0));
    const refundedAmount = (payment.refunds || []).reduce((refundedAmount, next) => {
        const amountAsBigNumber = new utils_1.BigNumber(next.raw_amount);
        return utils_1.MathBN.add(refundedAmount, amountAsBigNumber);
    }, utils_1.MathBN.convert(0));
    const totalRefundedAmount = utils_1.MathBN.add(refundedAmount, refundAmount);
    if (utils_1.MathBN.lt(capturedAmount, totalRefundedAmount)) {
        throw new utils_1.MedusaError(utils_1.MedusaError.Types.INVALID_DATA, `You are not allowed to refund more than the captured amount`);
    }
});
exports.refundPaymentWorkflowId = "refund-payment-workflow";
/**
 * This workflow refunds a payment. It's used by the
 * [Refund Payment Admin API Route](https://docs.medusajs.com/api/admin#payments_postpaymentsidrefund).
 *
 * You can use this workflow within your own customizations or custom workflows, allowing you
 * to refund a payment in your custom flows.
 *
 * @example
 * const { result } = await refundPaymentWorkflow(container)
 * .run({
 *   input: {
 *     payment_id: "payment_123",
 *   }
 * })
 *
 * @summary
 *
 * Refund a payment.
 */
exports.refundPaymentWorkflow = (0, workflows_sdk_1.createWorkflow)(exports.refundPaymentWorkflowId, (input) => {
    const payment = (0, common_1.useRemoteQueryStep)({
        entry_point: "payment",
        fields: [
            "id",
            "payment_collection_id",
            "currency_code",
            "amount",
            "raw_amount",
            "captures.raw_amount",
            "refunds.raw_amount",
        ],
        variables: { id: input.payment_id },
        list: false,
        throw_if_key_not_found: true,
    });
    (0, workflows_sdk_1.when)({ input }, ({ input }) => !!input.amount).then(() => (0, exports.validateRefundPaymentExceedsCapturedAmountStep)({
        payment,
        refundAmount: input.amount,
    }));
    const orderPaymentCollection = (0, common_1.useRemoteQueryStep)({
        entry_point: "order_payment_collection",
        fields: ["order.id"],
        variables: { payment_collection_id: payment.payment_collection_id },
        list: false,
        throw_if_key_not_found: true,
    }).config({ name: "order-payment-collection" });
    const order = (0, common_1.useRemoteQueryStep)({
        entry_point: "order",
        fields: ["id", "summary", "total", "currency_code", "region_id"],
        variables: { id: orderPaymentCollection.order.id },
        throw_if_key_not_found: true,
        list: false,
    }).config({ name: "order" });
    const refundReason = (0, workflows_sdk_1.when)("fetch-refund-reason", { input }, ({ input }) => !!input.refund_reason_id).then(() => {
        return (0, common_1.useRemoteQueryStep)({
            entry_point: "refund_reason",
            fields: ["id", "label", "code"],
            variables: { id: input.refund_reason_id },
            list: false,
            throw_if_key_not_found: true,
        }).config({ name: "refund-reason" });
    });
    const refundPayment = (0, refund_payment_1.refundPaymentStep)(input);
    const creditLineAmount = (0, workflows_sdk_1.transform)({ order, payment, input }, ({ order, payment, input }) => {
        const pendingDifference = order.summary?.raw_pending_difference ??
            order.summary?.pending_difference ??
            0;
        const amountToRefund = input.amount ?? payment.raw_amount ?? payment.amount;
        if (utils_1.MathBN.lt(pendingDifference, 0)) {
            const amountOwed = utils_1.MathBN.mult(pendingDifference, -1);
            return utils_1.MathBN.gt(amountToRefund, amountOwed)
                ? utils_1.MathBN.sub(amountToRefund, amountOwed)
                : 0;
        }
        return amountToRefund;
    });
    (0, workflows_sdk_1.when)({ orderPaymentCollection }, ({ orderPaymentCollection }) => {
        return !!orderPaymentCollection?.order?.id;
    }).then(() => {
        const orderTransactionData = (0, workflows_sdk_1.transform)({ input, refundPayment, orderPaymentCollection, order }, ({ input, refundPayment, orderPaymentCollection, order }) => {
            return refundPayment.refunds?.map((refund) => {
                return {
                    order_id: orderPaymentCollection.order.id,
                    amount: utils_1.MathBN.mult(input.amount ?? refund.raw_amount ?? refund.amount, -1),
                    currency_code: refundPayment.currency_code ?? order.currency_code,
                    reference_id: refund.id,
                    reference: "refund",
                };
            });
        });
        (0, add_order_transaction_1.addOrderTransactionStep)(orderTransactionData);
    });
    (0, workflows_sdk_1.when)({ creditLineAmount }, ({ creditLineAmount }) => utils_1.MathBN.gt(creditLineAmount, 0)).then(() => {
        create_order_refund_credit_lines_1.createOrderRefundCreditLinesWorkflow.runAsStep({
            input: {
                order_id: order.id,
                amount: creditLineAmount,
                reference: refundReason?.label,
                referenceId: refundReason?.code,
            },
        });
    });
    (0, common_1.emitEventStep)({
        eventName: utils_1.PaymentEvents.REFUNDED,
        data: { id: payment.id },
    });
    return new workflows_sdk_1.WorkflowResponse(payment);
});
//# sourceMappingURL=refund-payment.js.map